Node.js 的垃圾回收（GC）基于 **V8 引擎**，主要使用 **分代垃圾回收机制**，分为 **新生代** 和 **老生代**：

1. **新生代（Young Generation）**：存放短生命周期对象（如局部变量）。
   
   - **Scavenge 算法**（复制 + 交换）：
     
     - 新生代分为 **From** 和 **To** 两个区域。
     
     - 大多数对象最初分配在 **From** 区，GC 时存活的对象复制到 **To**，然后交换区域。
     
     - 存活多次的对象晋升到 **老生代**。

2. **老生代（Old Generation）**：存放生命周期较长的对象（如全局变量、缓存）。
   
   - **标记-清除（Mark-Sweep）**：标记不可达对象，然后清理。
   
   - **标记-整理（Mark-Compact）**：在清理的同时整理内存，防止碎片化。

3. **增量 & 并发 GC**：避免长时间暂停（**Incremental GC** 和 **Concurrent GC**）。

### **总结**

- **短生命周期对象 → 新生代（Scavenge GC）**

- **长生命周期对象 → 老生代（Mark-Sweep & Mark-Compact GC）**



## 防止碎片化怎么理解

### **为什么会有碎片化？**

在 **标记-清除（Mark-Sweep）** 阶段，**不可达的对象被回收，但它们原来的内存位置可能会留下空洞（碎片）**。

- **如果这些碎片过多**，新对象可能无法找到一块**连续的内存空间**存储，导致**内存利用率降低**，甚至需要频繁触发 GC 以腾出足够的空间。

### **如何防止碎片化？（Mark-Compact）**

1. **标记阶段（Mark）**：标记存活对象（即仍被引用的对象）。

2. **整理阶段（Compact）**：把存活对象**移动到一起，紧密排列**，从而**释放出连续的大块内存**。

3. **清除阶段（Sweep）**：清理未标记的对象，并更新指针引用关系。

### **形象理解**

假设 **内存是一个书架**：

- 你借了一些书，后来归还了几本（垃圾回收），但书架上留下了空格（碎片）。

- **整理（Compact）** 相当于**把剩下的书挪动到一起**，让书架更整齐，这样下次能更容易放新书（分配新对象）。

### **示例对比**

假设老生代的内存如下（`A, B, C` 是存活对象，`X, Y, Z` 是垃圾对象）：

**标记-清除（Mark-Sweep）后（会产生碎片）**：

```
[A][X][B][Y][C][Z] → 只清除 X, Y, Z，留下碎片
[A][ ][B][ ][C][ ]
```

**标记-整理（Mark-Compact）后（无碎片，内存连续）**：

```
[A][B][C][ ][ ][ ] → 把 A, B, C 紧挨着移动，释放出一整块连续的可用空间
```

### **总结**

- **`Mark-Sweep` 可能导致碎片化**，影响大对象分配。

- **`Mark-Compact` 会移动对象，让内存更紧凑**，提高分配效率，但**会增加额外的移动成本**

- **V8 在需要时会自动选择合适的 GC 机制**，以权衡性能和内存利用率。
